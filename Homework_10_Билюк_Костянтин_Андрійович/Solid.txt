1. 	1) Single responsibility (Принцип єдиного обов'язку) Кожен клас повинет відповідати за одну операцію. Декілька несумісних дій не повинен робити клас. 
Яскравий приклад. Маємо клас робот, який являється машиністом, слюсарем, продавцем та ще й космонавтом:) Ймовірність виникнення багів при такому розкладі буде більша аніж в тому випадку, якщо б ми мали краще 4 різних роботів, які відповідали би за своій власні задачі: слюсар - ремонтує механізми; продавець - продає товар клієнтам; машиніст - здійснює керування машиною; космонавт - здійснює політ у космос із певною метою.
	2) Open/Closed (Принцип відкритості/закритості) Він полягає в тому, що клас може бути розширеним але закритий для модифікації. Якщо ми захочемо добавити більше операцій для класу, то не потрібно замінювати їх на старі, так як ці зміни будуть позначатися на всіх системах, які працюють з даним класом. Краще робити розширення - додавати нові операції до вже існуючих. 
Приклад: маємо клас Робот, який вміє говорити. Трішки модифікуємо його, замінивши якийсь бажаний функціонал для нас. Як результат наш робот тепер навчився слухати, але втратив свою здатність розмовляти. Це сталося з великою ймовірністю через задівання старого функціоналу при додаванні нового. Щою вирішити нашу проблему, можемо створити інтерфейс, який буде буде мати в собі опис операції щодо слухових можливостей робота. Реалізуємо інтерфейс для класу робота. Вже на цьому етапі наш код стає більш гнучким, так як ми робимо лише розширення для класу, а не його модифікацію. В результаті ми отримаємо: наш робот навчився слухати та, як і раніше, зберіг здатність говорити.
	3) Liskov Substitution (Принцип підстановки Лісков) Наслідувальний клас повинен доповнювати аніж міняти поведінку базового класу. Роблячи override для якогось метода базового класу, ми порушуємо цей принцип. 
Приклад: маємо клас "Бариста"( його методи: приготувати кофе() ), наслідником якого є клас "ІнтернБариста" ( override "приготувати кофе()" { return *склянка води*} ). Створюємо по одному экземпляру наших класів. Уявімо ситуацію. Так вийшло, що нам потрібно приготувати кофе, але в наявності ми маємо лише об'єкт "ІнтернБариста". Замість чашечкі кави нам вернеться склянка води. Як результат: невдоволений клієнт та невиконаний принцип SOLID.
	4) Interface Segregation (Принцип розділення інтерфейсу) Не бажано робити клас залежним від метода, який він не використовує. Клас повинен виконувати лише ті методі, які йому потрібні. Якщо так виходить, що клас виконує зайвий функціон від реалізуючого інтерфейсу то це створює зайве виділення ресурсів для цього класу. При створення об'єкту такого класу, об'єкт займатиме більше ресурсів в програмі, хоча не міг би. Тому для вирішення цьої проблеми бажано роздробляти функціонал на декілька інтерфейсів. Якщо нам не знадобиться якийсь метод ми можем його видалити зовсім, або ж перемістисти його до іншого інтерфейсу, який, напевно, буде використаний в іншому класі в майбутньому.
Приклад. Маємо інтерфейс "IVehicleAcceleration" який має в собі метод "прискорення" і для його виконання потрібен транспортний засіб лише з двигуном внутрішнього згорання. Маємо також два класи "Автівка" та "Велосипед", що реалізуюсь цей інтерфейс. В результаті ми отримаємо ось що: об'єкт Автівки зможе реалізувати наш інтерфейс, в його все є для цього, а ось з об'єктом Велосипеда виникнуть проблеми, так як він не має бажаного двигуна, його пересування основане лише на крутінні педалей і не більше.
	5) Dependency Inversion (Принцип інверсії залежностей)
Абстракція не повинна залежить від деталей. Деталі повинні залежити від абстракції. Високорівневі класи не повинні залети від їх низькорівневих класів. Роблячи якійсь зміни в середині ієархії класів ми можем отримати відмову всієї системи через невикористання інтерфейсів або абстракції у важливих місцях взаємодії класів.
Приклад. Маємо завод, в якому є такий ланцюг: 

Робочі -> Cтанки(ДЕТАЛЬ1) -> Електроенергія. 

В один момент ДЕТАЛЬ1 ломається, замінюємо її на ДЕТАЛЬ2:

Робочі -> Cтанки(ДЕТАЛЬ2) -> Електроенергія. 

Так вийшло, що станок перестав працювати. Виявляється ДЕТАЛЬ2 не сумісна для споживання електроенергії. Для вирішення цієї проблеми потрібно добавити якийсь інтерфейс або ж абстракцію, від якої будуть залети деталі станка.

Робочі -> Cтанки(ДЕТАЛЬ2) -> Трансформатор -> Електроенергія. 

Наш трансформат сумісний зі всіма деталями станка, тому навіть при зміни механізму або деталей в станку це всеодно дасть можливість заживити його електроенергією


2. square -> rectangle На мою думку наведений приклад демонструє порушення принципу Лісків в явній формі, так як іх знаходження площи абсолютно неоднакове.

Ситуація. Наш square має поле метод "ЗнайтиПлощу" (Сторона * Сторона). Rectangle наслідує square, але метод батьківсього класу його не влаштовує, так як він находить не правильно площу для нього. Йому потрібно Сторона1 * Сторона2, тому він робить override, що вже порушує принципу Лісків. До того ж мається конфлікт сторін, так як для описання square потрібно лише одна сторона, а для rectangle - дві.

